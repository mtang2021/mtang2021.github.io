<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michael Tang - Digital Ecosystem</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="./styles/global.css">
    <link rel="stylesheet" href="./styles/terminal.css">
    <link rel="stylesheet" href="./styles/about.css">
    <link rel="stylesheet" href="./styles/experience.css">
    <link rel="stylesheet" href="./styles/projects.css">
    <link rel="stylesheet" href="./styles/contact.css">
</head>
<body>
    <!-- Custom Physics-Based Cursor System -->
    <div id="cursor-container">
        <div class="cursor-main"></div>
        <div class="cursor-aura"></div>
        <div class="cursor-interact"></div>
        <!-- Cursor trails will be generated by JS -->
    </div>
    
    <!-- Intro Sequence -->
    <div class="intro-sequence" id="intro-sequence">
        <pre class="intro-logo" id="intro-logo">
 _____ ______   ___  ________  ___  ___  ________  _______   ___               _________  ________  ________   ________     
|\   _ \  _   \|\  \|\   ____\|\  \|\  \|\   __  \|\  ___ \ |\  \             |\___   ___\\   __  \|\   ___  \|\   ____\    
\ \  \\\__\ \  \ \  \ \  \___|\ \  \\\  \ \  \|\  \ \   __/|\ \  \            \|___ \  \_\ \  \|\  \ \  \\ \  \ \  \___|    
 \ \  \\|__| \  \ \  \ \  \    \ \   __  \ \   __  \ \  \_|/_\ \  \                \ \  \ \ \   __  \ \  \\ \  \ \  \  ___  
  \ \  \    \ \  \ \  \ \  \____\ \  \ \  \ \  \ \  \ \  \_|\ \ \  \____            \ \  \ \ \  \ \  \ \  \\ \  \ \  \|\  \ 
   \ \__\    \ \__\ \__\ \_______\ \__\ \__\ \__\ \__\ \_______\ \_______\           \ \__\ \ \__\ \__\ \__\\ \__\ \_______\
    \|__|     \|__|\|__|\|_______|\|__|\|__|\|__|\|__|\|_______|\|_______|            \|__|  \|__|\|__|\|__| \|__|\|_______|

        </pre>
    </div>
    
    <!-- Main Container -->
    <div class="ecosystem-container">
        <!-- Particle Field Navigation -->
        <div class="particle-field" id="particle-field">
            <!-- Particles will be generated by JS -->
        </div>
        
        <!-- Terminal Core Interface -->
        <div class="terminal-interface" id="terminal-interface">
            <div class="terminal-header">
                <div class="terminal-buttons">
                    <div class="terminal-button terminal-button-close" id="terminal-close"></div>
                    <div class="terminal-button terminal-button-minimize" id="terminal-minimize"></div>
                    <div class="terminal-button terminal-button-maximize" id="terminal-maximize"></div>
                </div>
                <div class="terminal-title">mtang@digital-ecosystem ~ $</div>
            </div>
            <div class="terminal-content" id="terminal-content">
                <!-- Terminal content will be dynamically typed in -->
                <div class="terminal-input-line">
                    <span class="terminal-prompt">$</span>
                    <input type="text" class="terminal-input" id="terminal-input" placeholder="Type a command...">
                    <span class="terminal-cursor"></span>
                </div>
            </div>
        </div>
        
        <!-- Navigation Nodes -->
        <div class="nav-nodes">
            <div class="nav-node active" data-section="intro"></div>
            <div class="nav-node" data-section="about"></div>
            <div class="nav-node" data-section="experience"></div>
            <div class="nav-node" data-section="projects"></div>
            <div class="nav-node" data-section="contact"></div>
        </div>
        
        <!-- Sections -->
        <div class="section" id="about-section">
            <div class="about-container">
                <div class="about-header">
                    <h1 class="about-title interactive-text">MICHAEL_TANG</h1>
                    <p class="about-subtitle">AI & Software Engineer</p>
                </div>
                
                <p class="about-text">
                    An aspiring <span class="highlight">AI engineer</span> with hands-on experience in machine learning, NLP, and financial data analysis. Strong technical background in <span class="highlight">LLM fine-tuning</span>, reinforcement learning, and back-end development, with a focus on scalable and data-driven solutions.
                </p>
                
                <!-- Living Data Visualization -->
                <div class="data-visualization" id="skills-visualization">
                    <!-- Data points will be generated by JS -->
                </div>
            </div>
        </div>
        
        <div class="section" id="experience-section">
            <div class="experience-container">
                <div class="experience-header">
                    <h1 class="about-title interactive-text">EXPERIENCE</h1>
                    <p class="about-subtitle">Professional Journey</p>
                </div>
                
                <div class="experience-items">
                    <div class="experience-item">
                        <div class="experience-date">Dec 2024 - Present</div>
                        <h3 class="experience-title">Staff Accountant</h3>
                        <div class="experience-company">WellBorn Management</div>
                        <p class="experience-description">
                            Administered general ledger activities, prepared financial statements, and reconciled accounts for 10+ hospitality brands. Supervised accounts payable/receivable, payroll processing, revenue reporting, and bank reconciliations to ensure financial integrity for over $11 million in annual revenue.
                        </p>
                    </div>
                    
                    <div class="experience-item">
                        <div class="experience-date">Aug 2024 - Present</div>
                        <h3 class="experience-title">Freelance Writer</h3>
                        <div class="experience-company">Grammarly</div>
                        <p class="experience-description">
                            Evaluated 1,400+ text documents and snippets as part of an internal initiative designed to improve the quality, accuracy, and contextual relevance of AI-powered writing suggestions. Supported feature development by refining existing algorithms and evaluating prototypes.
                        </p>
                    </div>
                    
                    <div class="experience-item">
                        <div class="experience-date">Apr 2024 - Dec 2024</div>
                        <h3 class="experience-title">Contract AI Writing Evaluator</h3>
                        <div class="experience-company">Outlier</div>
                        <p class="experience-description">
                            Evaluated and refined training data for LLMs including Google Gemini, by analyzing 2,000+ AI-generated outputs across domains such as Google Flights, Hotels, and YouTube. Applied Reinforcement Learning from Human Feedback (RLHF) to optimize AI accuracy, ensuring ethical and factual responses.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section" id="projects-section">
            <div class="about-container">
                <div class="about-header">
                    <h1 class="about-title interactive-text">PROJECTS</h1>
                    <p class="about-subtitle">Creative Works</p>
                </div>
                
                <div class="project-cards">
                    <div class="project-card interactive-element">
                        <h3 class="project-title">Stock Price Prediction Model</h3>
                        <div class="project-tech">Python, Ridge Regression, CNN, SVR</div>
                        <p class="project-description">
                            Engineered a stock price forecasting model that achieved an R² score of 0.984, leveraging Ridge Regression, CNN, and SVR to enhance predictive accuracy. Designed data preprocessing techniques and integrated visualization tools.
                        </p>
                        <div class="project-metric">
                            <div class="metric-label">Accuracy</div>
                            <div class="metric-bar">
                                <div class="metric-fill" style="width: 98.4%"></div>
                            </div>
                            <div class="metric-value">98.4%</div>
                        </div>
                        <a href="projects\ML4641\index.html" target="_blank" class="project-button" data-cursor="hover">View Project</a>
                    </div>
                    
                    <div class="project-card interactive-element">
                        <h3 class="project-title">NLP Headline Classification Model</h3>
                        <div class="project-tech">PyTorch, NLTK, Pandas</div>
                        <p class="project-description">
                            Built an NLP classifier that distinguishes satirical from real news headlines using a Neural Bag of Words model. Implemented custom PyTorch datasets, token embeddings, and achieved 86%+ F1 score by capturing distinctive linguistic patterns in satirical writing.                        </p>
                        <div class="project-metric">
                            <div class="metric-label">F1 Score</div>
                            <div class="metric-bar">
                                <div class="metric-fill" style="width: 86.5%"></div>
                            </div>
                            <div class="metric-value">86.5%</div>
                        </div>
                        <a class="project-button" data-cursor="hover">N/A</a>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section" id="contact-section">
            <div class="about-container">
                <div class="about-header">
                    <h1 class="about-title interactive-text">CONTACT</h1>
                    <p class="about-subtitle">Get in Touch</p>
                </div>
                
                <div class="contact-content">
                    <p class="about-text">
                        Interested in collaborating on AI projects or need a skilled developer for your team? Feel free to reach out through any of the channels below.
                    </p>
                    
                    <div class="contact-cards">
                        <div class="contact-card interactive-element">
                            <div class="contact-icon">
                                <i class="fas fa-envelope"></i>
                            </div>
                            <div class="contact-label">Email</div>
                            <div class="contact-value">mta&#110;g2&#48;21&#64;&#103;m&#97;i&#108;&#46;&#99;om</div>
                        </div>
                        
                        <div class="contact-card interactive-element">
                            <div class="contact-icon">
                                <i class="fas fa-phone"></i>
                            </div>
                            <div class="contact-label">Phone</div>
                            <div class="contact-value">+1 404-834-0526</div>
                        </div>
                        
                        <div class="contact-card interactive-element">
                            <div class="contact-icon">
                                <i class="fab fa-linkedin"></i>
                            </div>
                            <div class="contact-label">LinkedIn</div>
                            <div class="contact-value">mtang2021</div>
                        </div>
                        
                        <div class="contact-card interactive-element">
                            <div class="contact-icon">
                                <i class="fas fa-map-marker-alt"></i>
                            </div>
                            <div class="contact-label">Location</div>
                            <div class="contact-value">Morrow, Georgia</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Show intro sequence
            const introSequence = document.getElementById('intro-sequence');
            const introLogo = document.getElementById('intro-logo');
            
            // Play intro animation
            setTimeout(() => {
                introLogo.classList.add('visible');
            }, 500);
            
            setTimeout(() => {
                introLogo.classList.remove('visible');
                introSequence.style.opacity = '0';
                setTimeout(() => {
                    introSequence.style.display = 'none';
                    initializeApp();
                }, 1000);
            }, 3000);
        });
        
        function initializeApp() {
            // Initialize terminal interface
            const terminal = document.getElementById('terminal-interface');
            terminal.style.opacity = '1';
            
            // Setup physics-based cursor
            setupCursor();
            
            // Generate particle field
            generateParticleField();
            
            // Initialize terminal functionality
            initializeTerminal();
            
            // Setup interactive text
            setupInteractiveText();
            
            // Setup navigation
            setupNavigation();
            
            // Generate living data visualization
            generateSkillsVisualization();
            
            // Make project cards and contact cards interactive
            setupInteractiveElements();
        }
        
        // Physics-based cursor with trails
        function setupCursor() {
            const cursorContainer = document.getElementById('cursor-container');
            const cursorMain = document.querySelector('.cursor-main');
            const cursorAura = document.querySelector('.cursor-aura');
            const cursorInteract = document.querySelector('.cursor-interact');
            
            // Trail properties
            const maxTrails = 0;
            const trails = [];
            
            // Create cursor trails
            for (let i = 0; i < maxTrails; i++) {
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.opacity = '0';
                cursorContainer.appendChild(trail);
                trails.push({
                    element: trail,
                    x: 0,
                    y: 0,
                    // Randomize the delay for more organic movement
                    delay: i * (100 / maxTrails),
                    size: Math.max(2, 6 - (i * 0.25)) // Gradually smaller trails
                });
            }
            
            // Track cursor position
            let mouseX = 0, mouseY = 0;
            let cursorX = 0, cursorY = 0;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                // Update cursor scale based on movement speed
                const dx = e.movementX;
                const dy = e.movementY;
                const speed = Math.sqrt(dx*dx + dy*dy);
                const scale = 1 + Math.min(speed / 20, 0.5);
                cursorMain.style.transform = `translate(-50%, -50%) scale(${scale})`;
                
                // Check if cursor is over interactive elements
                const element = document.elementFromPoint(e.clientX, e.clientY);
                if (element && element.closest('[data-cursor="hover"]') || 
                    element && element.tagName === 'A' || 
                    element && element.tagName === 'BUTTON') {
                    cursorMain.style.borderColor = 'var(--highlight)';
                    cursorMain.style.transform = `translate(-50%, -50%) scale(1.5)`;
                } else {
                    cursorMain.style.borderColor = 'var(--text-color)';
                }
                
                // Physical interaction with nearby elements
                const interactiveElements = document.querySelectorAll('.interactive-text, .nav-node, .particle');
                interactiveElements.forEach(el => {
                    const rect = el.getBoundingClientRect();
                    const elCenterX = rect.left + rect.width / 2;
                    const elCenterY = rect.top + rect.height / 2;
                    
                    // Calculate distance
                    const dx = mouseX - elCenterX;
                    const dy = mouseY - elCenterY;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Apply physics effects based on distance
                    if (distance < 100) {
                        // Calculate repulsion force (inverse to distance)
                        const force = Math.min(1 - distance / 100, 0.4);
                        const angle = Math.atan2(dy, dx);
                        const moveX = Math.cos(angle) * force * 5;
                        const moveY = Math.sin(angle) * force * 5;
                        
                        // Apply transformation
                        if (el.classList.contains('interactive-text')) {
                            el.style.transform = `translate(${moveX}px, ${moveY}px)`;
                        } else if (el.classList.contains('particle')) {
                            el.style.transform = `translate(${moveX}px, ${moveY}px)`;
                            el.style.backgroundColor = 'var(--highlight)';
                        } else {
                            el.style.transform = `translate(${moveX}px, ${moveY}px)`;
                        }
                    } else {
                        // Reset when cursor is far away
                        if (!el.classList.contains('char-wrapper')) {
                            el.style.transform = '';
                        }
                        if (el.classList.contains('particle')) {
                            el.style.backgroundColor = 'var(--highlight-dim)';
                        }
                    }
                });
            });
            
            // Animation loop for cursor and trails
            function animateCursor() {
                // Smoothly move cursor to mouse position (easing effect)
                cursorX += (mouseX - cursorX) * 0.1;
                cursorY += (mouseY - cursorY) * 0.1;
                
                // Update main cursor position
                cursorMain.style.left = `${cursorX}px`;
                cursorMain.style.top = `${cursorY}px`;
                
                // Update cursor aura
                cursorAura.style.left = `${cursorX}px`;
                cursorAura.style.top = `${cursorY}px`;
                
                // Update cursor interact area
                cursorInteract.style.left = `${cursorX}px`;
                cursorInteract.style.top = `${cursorY}px`;
                
                // Update trails with staggered delay
                trails.forEach((trail, index) => {
                    // Calculate trail position with delay
                    trail.x += (mouseX - trail.x) * (0.1 - index * 0.005);
                    trail.y += (mouseY - trail.y) * (0.1 - index * 0.005);
                    
                    // Apply position
                    trail.element.style.left = `${trail.x}px`;
                    trail.element.style.top = `${trail.y}px`;
                    
                    // Set size
                    trail.element.style.width = `${trail.size}px`;
                    trail.element.style.height = `${trail.size}px`;
                    
                    // Fade in trails gradually
                    if (trail.element.style.opacity < 0.7) {
                        trail.element.style.opacity = Math.min(parseFloat(trail.element.style.opacity) + 0.05, 0.7 - (index * 0.03));
                    }
                });
                
                requestAnimationFrame(animateCursor);
            }
            
            // Start animation loop
            animateCursor();
        }
        
        // Generate particle field for navigation
        function generateParticleField() {
            const particleField = document.getElementById('particle-field');
            const particleCount = Math.min(window.innerWidth / 10, 150); // Responsive particle count
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                // Position randomly
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                // Animate particle with random duration
                const duration = 20 + Math.random() * 20;
                particle.style.animation = `float ${duration}s infinite ease-in-out`;
                
                particleField.appendChild(particle);
            }
            
            // Make particles move slightly on scroll
            window.addEventListener('scroll', () => {
                const scrollY = window.scrollY;
                const particles = document.querySelectorAll('.particle');
                
                particles.forEach((particle, index) => {
                    // Create parallax effect with different speeds
                    const speed = 0.05 + (index % 5) * 0.01;
                    particle.style.transform = `translateY(${scrollY * speed}px)`;
                });
            });
        }
        
        // Initialize terminal functionality
        function initializeTerminal() {
            const terminalContent = document.getElementById('terminal-content');
            const terminalInput = document.getElementById('terminal-input');
            const terminalClose = document.getElementById('terminal-close');
            const terminalMinimize = document.getElementById('terminal-minimize');
            const terminalMaximize = document.getElementById('terminal-maximize');
            
            // Terminal state
            let isMinimized = false;
            const terminalInterface = document.getElementById('terminal-interface');
            
            // Terminal boot sequence content
            const bootSequence = [
                { type: 'command', text: 'echo "Welcome to Michael Tang\'s Digital Ecosystem"' },
                { type: 'output', text: 'Welcome to Michael Tang\'s Digital Ecosystem' },
                { type: 'command', text: 'whoami' },
                { type: 'output', text: 'Michael Tang - AI and Software Engineer specializing in machine learning, NLP, and financial data analysis.' },
                { type: 'command', text: 'cat navigation.txt' },
                { type: 'output', text: `Navigation Commands:` },
                { type: 'output', text: `• view about - Display information about me` },
                { type: 'output', text: `• view experience - Show professional background` },
                { type: 'output', text: `• view projects - Browse portfolio projects` },
                { type: 'output', text: `• view contact - Get contact information` },
                { type: 'output', text: `• clear - Clear the terminal` },
                { type: 'output', text: `• help - Display more command info` }
            ];
            
            // Text anim
            function typeText(element, text, speed = 4) {
                return new Promise(resolve => {
                    let i = 0;
                    element.textContent = '';
                    
                    function typeNextChar() {
                        if (i < text.length) {
                            element.textContent += text.charAt(i);
                            i++;
                            setTimeout(typeNextChar, speed);
                        } else {
                            resolve();
                        }
                    }
                    
                    typeNextChar();
                });
            }

            // Function to add a line to terminal with typing animation
            async function addTypedLine(content, isCommand = true, typingSpeed = 4) {
                const line = document.createElement('div');
                line.className = 'terminal-line';
                terminalContent.insertBefore(line, terminalContent.lastElementChild);
                
                if (isCommand) {
                    const prompt = document.createElement('span');
                    prompt.className = 'terminal-prompt';
                    prompt.textContent = '$ ';
                    line.appendChild(prompt);
                    
                    const command = document.createElement('span');
                    command.className = 'terminal-command';
                    line.appendChild(command);
                    
                    // Type the command character by character
                    await typeText(command, content, typingSpeed);
                } else {
                    // Type the output character by character
                    await typeText(line, content, typingSpeed);
                }
                
                // Add visible class for fade-in effect
                line.classList.add('visible');
                
                // Scroll to bottom
                terminalContent.scrollTop = terminalContent.scrollHeight;
                
                return line;
            }

            // Start the boot sequence
            async function startBootSequence() {
                // Faster typing for commands, slower for reading outputs
                const commandSpeed = 15; 
                const outputSpeed = 5;
                
                for (const item of bootSequence) {
                    if (item.type === 'command') {
                        await addTypedLine(item.text, true, commandSpeed);
                        // Pause after command to simulate execution
                        await new Promise(resolve => setTimeout(resolve, 200));
                    } else {
                        await addTypedLine(item.text, false, outputSpeed);
                        // Longer pause after output to give time to read
                        await new Promise(resolve => setTimeout(resolve, 400));
                    }
                }
                
                // Focus input after boot sequence completes
                terminalInput.focus();
            }

            // Terminal commands
            const commands = {
                'help': () => {
                    addTypedLine('Available commands:', false);
                    addTypedLine('• clear - Clear the terminal', false);
                    addTypedLine('• exit - Minimize the terminal', false);
                    addTypedLine('• help - Display this help message', false);
                    addTypedLine('• view [section] - View a section (about, experience, projects, contact)', false);

                },
                'clear': () => {
                    // Remove all lines except the input line
                    const lines = terminalContent.querySelectorAll('.terminal-line');
                    lines.forEach(line => {
                        if (!line.classList.contains('terminal-input-line')) {
                            line.remove();
                        }
                    });
                },
                'exit': () => {
                    minimizeTerminal();
                },
                'view': (section) => {
                    if (!section) {
                        addTypedLine('Please specify a section to view: about, experience, projects, skills, contact', false);
                        return;
                    }
                    
                    // Find the nav node for this section
                    const navNodes = document.querySelectorAll('.nav-node');
                    let foundSection = false;
                    
                    navNodes.forEach(node => {
                        if (node.dataset.section === section) {
                            node.click();
                            foundSection = true;
                        }
                    });
                    
                    if (!foundSection) {
                        // Try to match sections more loosely
                        if (section === 'projects' || section === 'project') {
                            navNodes.forEach(node => {
                                if (node.dataset.section === 'projects') {
                                    node.click();
                                    foundSection = true;
                                }
                            });
                        } else if (section === 'contact' || section === 'contacts') {
                            navNodes.forEach(node => {
                                if (node.dataset.section === 'contact') {
                                    node.click();
                                    foundSection = true;
                                }
                            });
                        }
                    }
                    
                    if (foundSection) {
                        addTypedLine(`Navigating to ${section} section...`, false);
                        
                        // If terminal is maximized, minimize it
                        setTimeout(() => {
                            minimizeTerminal();
                        }, 1000);
                    } else {
                        addTypedLine(`Section "${section}" not found. Available sections: about, experience, projects, contact`, false);
                    }
                }
            };
            
            // Add a new line to terminal
            function addTerminalLine(text, isCommand = true, delay = 0) {
                const line = document.createElement('div');
                line.className = 'terminal-line';
                
                if (isCommand) {
                    line.innerHTML = `<span class="terminal-prompt">$</span> <span class="terminal-command">${text}</span>`;
                } else {
                    line.textContent = text;
                }
                
                terminalContent.insertBefore(line, terminalContent.lastElementChild);
                
                // Animate line appearance
                setTimeout(() => {
                    line.classList.add('visible');
                }, delay);
                
                // Scroll to bottom
                terminalContent.scrollTop = terminalContent.scrollHeight;
                
                return line;
            }
            
            // Process terminal input
            terminalInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const input = terminalInput.value.trim();
                    terminalInput.value = '';
                    
                    if (input) {
                        // Add command to terminal
                        addTerminalLine(input, true);
                        
                        // Process command
                        const args = input.split(' ');
                        const command = args[0].toLowerCase();
                        const commandArgs = args.slice(1);
                        
                        if (commands[command]) {
                            commands[command](...commandArgs);
                        } else {
                            addTerminalLine(`Command not found: ${command}. Type 'help' for available commands.`, false);
                        }
                    }
                }
            });
            
            // Terminal controls
            terminalClose.addEventListener('click', () => {
                terminalInterface.style.opacity = '0';
                setTimeout(() => {
                    terminalInterface.style.display = 'none';
                }, 700);
            });

            terminalMinimize.addEventListener('click', () => {
                terminalInterface.style.transform = 'translate(-50%, 46vh) scale(1)';
                terminalInterface.style.opacity = '0.4';
                isMinimized = true;
            });

            terminalMaximize.addEventListener('click', () => {
                terminalInterface.style.transform = 'translate(-50%, -50%) scale(1)';
                terminalInterface.style.opacity = '1';
                isMinimized = false;
                
                // Focus input
                setTimeout(() => {
                    terminalInput.focus();
                }, 700);
            })
            
            document.querySelector('.terminal-header').addEventListener('click', (e) => {
                if (e.target.closest('.terminal-button')) return;
                
                if (isMinimized) {
                    maximizeTerminal();
                } else {
                    minimizeTerminal();
                }
            });
            
            // Start boot sequence after short delay
            setTimeout(() => {
                startBootSequence();
            }, 500);
        }
        
        // Setup interactive text
        function setupInteractiveText() {
            const interactiveTextElements = document.querySelectorAll('.interactive-text');
            
            interactiveTextElements.forEach(element => {
                const text = element.textContent;
                element.textContent = '';
                
                // Create dynamic shape for this text element
                const dynamicShape = document.createElement('div');
                dynamicShape.className = 'dynamic-shape';
                element.appendChild(dynamicShape);
                
                // Split text into characters
                for (let i = 0; i < text.length; i++) {
                    const charWrapper = document.createElement('span');
                    charWrapper.className = 'char-wrapper';
                    charWrapper.textContent = text[i];
                    
                    // Set initial random position
                    charWrapper.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                    charWrapper.style.opacity = '0';
                    
                    element.appendChild(charWrapper);
                    
                    // Animate character into position
                    setTimeout(() => {
                        charWrapper.style.transform = 'translate(0, 0)';
                        charWrapper.style.opacity = '1';
                    }, 500 + i * 10);
                }
                
                // Track mouse position for this text element
                element.addEventListener('mousemove', (e) => {
                    const rect = element.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Position the dynamic shape
                    dynamicShape.style.left = x + 'px';
                    dynamicShape.style.top = y + 'px';
                    dynamicShape.style.opacity = '1';
                    
                    // Affect characters based on proximity
                    const charWrappers = element.querySelectorAll('.char-wrapper');
                    charWrappers.forEach((charWrapper, index) => {
                        const charRect = charWrapper.getBoundingClientRect();
                        const charX = charRect.left + charRect.width / 2 - rect.left;
                        const charY = charRect.top + charRect.height / 2 - rect.top;
                        
                        // Calculate distance
                        const dx = x - charX;
                        const dy = y - charY;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Apply effects based on distance
                        if (distance < 50) {
                            // Repulsion effect
                            const force = (1 - distance / 50) * 10;
                            const angle = Math.atan2(dy, dx);
                            const moveX = -Math.cos(angle) * force;
                            const moveY = -Math.sin(angle) * force;
                            
                            charWrapper.style.transform = `translate(${moveX}px, ${moveY}px)`;
                            charWrapper.style.color = 'var(--highlight)';
                            charWrapper.style.textShadow = 'var(--glow)';
                        } else {
                            // Reset
                            charWrapper.style.transform = 'translate(0, 0)';
                            charWrapper.style.color = '';
                            charWrapper.style.textShadow = '';
                        }
                    });
                });
                
                // Reset on mouse leave
                element.addEventListener('mouseleave', () => {
                    dynamicShape.style.opacity = '0';
                    
                    const charWrappers = element.querySelectorAll('.char-wrapper');
                    charWrappers.forEach(charWrapper => {
                        charWrapper.style.transform = 'translate(0, 0)';
                        charWrapper.style.color = '';
                        charWrapper.style.textShadow = '';
                    });
                });
            });
        }
        
        // Setup navigation
        function setupNavigation() {
            const navNodes = document.querySelectorAll('.nav-node');
            const sections = document.querySelectorAll('.section');
            
            navNodes.forEach(node => {
                node.addEventListener('click', () => {
                    // Update active state
                    navNodes.forEach(n => n.classList.remove('active'));
                    node.classList.add('active');
                    
                    const sectionId = node.dataset.section;
                    
                    // Intro is special case
                    if (sectionId === 'intro') {
                        sections.forEach(section => {
                            section.classList.remove('active');
                        });
                        
                        // Show terminal
                        const terminal = document.getElementById('terminal-interface');
                        terminal.style.display = 'block';
                        terminal.style.opacity = '1';
                        terminal.style.transform = 'translate(-50%, -50%) scale(1)';
                        return;
                    }
                    
                    // Hide terminal if visible
                    const terminal = document.getElementById('terminal-interface');
                    terminal.style.opacity = '0.4';
                    terminal.style.transform = 'translate(-50%, 40vh) scale(0.2)';
                    
                    // Show selected section
                    sections.forEach(section => {
                        if (section.id === `${sectionId}-section`) {
                            section.classList.add('active');
                            
                            // Animate experience items if showing experience section
                            if (sectionId === 'experience') {
                                const experienceItems = section.querySelectorAll('.experience-item');
                                experienceItems.forEach((item, index) => {
                                    setTimeout(() => {
                                        item.classList.add('visible');
                                    }, 300 + index * 200);
                                });
                            }
                        } else {
                            section.classList.remove('active');
                        }
                    });
                });
            });
        }
        
        // Generate living data visualization for skills
        function generateSkillsVisualization() {
            const container = document.getElementById('skills-visualization');
            if (!container) return;
            
            // Skills data with ratings
            const skills = [
                { name: 'Python', value: 85 },
                { name: 'NLP', value: 78 },
                { name: 'Machine Learning', value: 85 },
                { name: 'LLM Fine-tuning', value: 94 },
                { name: 'Data Analysis', value: 92 },
                { name: 'RLHF', value: 94 }
            ];
            
            // Generate data points
            skills.forEach((skill, index) => {
                const angle = (index / skills.length) * Math.PI * 2;
                const radius = (skill.value / 100) * (container.offsetWidth / 2 - 130);
                
                // Calculate position
                const x = container.offsetWidth / 2 + Math.cos(angle) * radius;
                const y = container.offsetHeight / 2 + Math.sin(angle) * radius;
                
                // Create data point
                const dataPoint = document.createElement('div');
                dataPoint.className = 'data-point';
                dataPoint.setAttribute('data-skill', skill.name);
                dataPoint.style.left = `${x}px`;
                dataPoint.style.top = `${y}px`;
                
                dataPoint.addEventListener('mouseenter', () => {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.textContent = `${skill.name}: ${skill.value}%`;
                    tooltip.style.position = 'absolute';
                    tooltip.style.left = `${x}px`;
                    tooltip.style.top = `${y - 20}px`;
                    tooltip.style.backgroundColor = 'var(--highlight)';
                    tooltip.style.color = 'var(--bg-color)';
                    tooltip.style.padding = '5px';
                    tooltip.style.borderRadius = '3px';
                    tooltip.style.fontSize = '12px';
                    tooltip.style.pointerEvents = 'none';
                    tooltip.style.zIndex = '1000';
                    container.appendChild(tooltip);
                    
                    dataPoint.addEventListener('mouseleave', () => {
                        tooltip.remove();
                    });
                });
                
                
                
                // Connect to center with line
                const line = document.createElement('div');
                line.className = 'data-line';
                line.style.left = `${container.offsetWidth / 2}px`;
                line.style.top = `${container.offsetHeight / 2}px`;
                line.style.width = `${radius}px`;
                line.style.transform = `rotate(${angle}rad)`;
                
                container.appendChild(line);
                container.appendChild(dataPoint);
                
                // Add label
                const label = document.createElement('div');
                label.className = 'data-label';
                label.textContent = skill.name;
                label.style.position = 'absolute';
                label.style.left = `${x}px`;
                label.style.top = `${y}px`;
                label.style.transform = 'translate(-50%, 50%)';
                label.style.fontSize = '16px';
                label.style.color = 'var(--highlight)';
                
                container.appendChild(label);
            });
            
            // Make visualization alive
            setInterval(() => {
                const dataPoints = container.querySelectorAll('.data-point');
                const lines = container.querySelectorAll('.data-line');
                
                dataPoints.forEach((point, index) => {
                    // Get current position
                    const skill = skills[index];
                    const angle = (index / skills.length) * Math.PI * 2;
                    
                    // Add some oscillation to make it living
                    const oscillation = Math.sin(Date.now() / 1000 + index) * 2;
                    const radius = ((skill.value + oscillation) / 100) * (container.offsetWidth / 2 - 130);
                    
                    // Update position
                    const x = container.offsetWidth / 2 + Math.cos(angle) * radius;
                    const y = container.offsetHeight / 2 + Math.sin(angle) * radius;
                    
                    point.style.left = `${x}px`;
                    point.style.top = `${y}px`;
                    
                    // Update line
                    lines[index].style.width = `${radius}px`;
                });
            }, 50);
        }
        
        // Make project cards and contact cards interactive
        function setupInteractiveElements() {
            // Make project and contact cards interactive
            const interactiveElements = document.querySelectorAll('.interactive-element');
            
            interactiveElements.forEach(element => {
                element.addEventListener('mouseenter', (e) => {
                    // Scale up slightly
                    element.style.transform = 'translateY(-5px)';
                    element.style.boxShadow = 'var(--glow)';
                });
                
                element.addEventListener('mouseleave', () => {
                    element.style.transform = '';
                    element.style.boxShadow = '';
                });
                
                // Make the element physically responsive to cursor
                element.setAttribute('data-cursor', 'hover');
            });
            
            // Make project metrics pulse
            const metricFills = document.querySelectorAll('.metric-fill');
            metricFills.forEach(fill => {
                // Initial width from style
                const width = fill.style.width;
                
                // Create subtle animation
                setInterval(() => {
                    // Get current width value
                    const currentWidth = parseFloat(width);
                    // Add small random variation
                    const variation = Math.random() * 2 - 1; // -1 to 1
                    const newWidth = Math.max(0, Math.min(100, currentWidth + variation));
                    fill.style.width = `${newWidth}%`;
                }, 1000);
            });
        }
    </script>
</body>
</html>
