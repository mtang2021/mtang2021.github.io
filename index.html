<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Michael Tang - Digital Ecosystem</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="./styles/global.css">
    <link rel="stylesheet" href="./styles/terminal.css">
    <link rel="stylesheet" href="./styles/about.css">
    <link rel="stylesheet" href="./styles/experience.css">
    <link rel="stylesheet" href="./styles/projects.css">
    <link rel="stylesheet" href="./styles/contact.css">
</head>
<body>
    <!-- Custom Physics-Based Cursor System -->
    <div id="cursor-container">
        <div class="cursor-main"></div>
        <div class="cursor-aura"></div>
        <div class="cursor-interact"></div>
        <!-- Cursor trails will be generated by JS -->
    </div>
    
    <!-- Intro Sequence -->
    <div class="intro-sequence" id="intro-sequence">
        <pre class="intro-logo" id="intro-logo">
 _____ ______   ___  ________  ___  ___  ________  _______   ___               _________  ________  ________   ________     
|\   _ \  _   \|\  \|\   ____\|\  \|\  \|\   __  \|\  ___ \ |\  \             |\___   ___\\   __  \|\   ___  \|\   ____\    
\ \  \\\__\ \  \ \  \ \  \___|\ \  \\\  \ \  \|\  \ \   __/|\ \  \            \|___ \  \_\ \  \|\  \ \  \\ \  \ \  \___|    
 \ \  \\|__| \  \ \  \ \  \    \ \   __  \ \   __  \ \  \_|/_\ \  \                \ \  \ \ \   __  \ \  \\ \  \ \  \  ___  
  \ \  \    \ \  \ \  \ \  \____\ \  \ \  \ \  \ \  \ \  \_|\ \ \  \____            \ \  \ \ \  \ \  \ \  \\ \  \ \  \|\  \ 
   \ \__\    \ \__\ \__\ \_______\ \__\ \__\ \__\ \__\ \_______\ \_______\           \ \__\ \ \__\ \__\ \__\\ \__\ \_______\
    \|__|     \|__|\|__|\|_______|\|__|\|__|\|__|\|__|\|_______|\|_______|            \|__|  \|__|\|__|\|__| \|__|\|_______|

        </pre>
    </div>
    
    <!-- Main Container -->
    <div class="ecosystem-container">
        <!-- Particle Field Navigation -->
        <div class="particle-field" id="particle-field">
            <!-- Particles will be generated by JS -->
        </div>
        
        <!-- Interactive Constellations System -->
        <div class="constellation-system" id="constellation-system">
            <canvas id="constellation-canvas"></canvas>
            </div>
        </div>
        
        <!-- Terminal Core Interface -->
        <div class="terminal-interface" id="terminal-interface">
            <div class="terminal-header">
                <div class="terminal-buttons">
                    <div class="terminal-button terminal-button-close" id="terminal-close"></div>
                    <div class="terminal-button terminal-button-minimize" id="terminal-minimize"></div>
                    <div class="terminal-button terminal-button-maximize" id="terminal-maximize"></div>
                </div>
                <div class="terminal-title">mtang@digital-ecosystem ~ $</div>
            </div>
            <div class="terminal-content" id="terminal-content">
                <!-- Terminal content will be dynamically typed in -->
                <div class="terminal-input-line">
                    <span class="terminal-prompt">$</span>
                    <input type="text" class="terminal-input" id="terminal-input" placeholder="Type a command...">
                    <span class="terminal-cursor"></span>
                </div>
            </div>
        </div>
        
        <!-- Navigation Nodes -->
        <div class="nav-nodes">
            <div class="nav-node active" data-section="intro"></div>
            <div class="nav-node" data-section="about"></div>
            <div class="nav-node" data-section="experience"></div>
            <div class="nav-node" data-section="projects"></div>
            <div class="nav-node" data-section="contact"></div>
        </div>
        
        <!-- Sections -->
        <div class="section" id="about-section">
            <div class="about-container">
                <div class="about-header sticky-header">
                    <h1 class="about-title interactive-text">MICHAEL_TANG</h1>
                    <p class="about-subtitle">AI & Software Engineer</p>
                </div>
                
                <p class="about-text">
                    An aspiring <span class="highlight">AI engineer</span> with hands-on experience in machine learning, NLP, and financial data analysis. Strong technical background in <span class="highlight">LLM fine-tuning</span>, reinforcement learning, and back-end development, with a focus on scalable and data-driven solutions.
                </p>
                
                <!-- Living Data Visualization -->
                <div class="data-visualization" id="skills-visualization">
                    <!-- Data points will be generated by JS -->
                </div>
            </div>
        </div>
        
        <div class="section" id="experience-section">
            <div class="experience-container">
                <div class="experience-header sticky-header">
                    <h1 class="about-title interactive-text">EXPERIENCE</h1>
                    <p class="about-subtitle">Professional Journey</p>
                </div>
                
                <div class="experience-items">
                    <div class="experience-item">
                        <div class="experience-date">Dec 2024 - Present</div>
                        <h3 class="experience-title">Staff Accountant</h3>
                        <div class="experience-company">WellBorn Management</div>
                        <p class="experience-description">
                            Administered general ledger activities, prepared financial statements, and reconciled accounts for 10+ hospitality brands. Supervised accounts payable/receivable, payroll processing, revenue reporting, and bank reconciliations to ensure financial integrity for over $11 million in annual revenue.
                        </p>
                    </div>
                    
                    <div class="experience-item">
                        <div class="experience-date">Aug 2024 - Present</div>
                        <h3 class="experience-title">Freelance Writer</h3>
                        <div class="experience-company">Grammarly</div>
                        <p class="experience-description">
                            Evaluated 1,400+ text documents and snippets as part of an internal initiative designed to improve the quality, accuracy, and contextual relevance of AI-powered writing suggestions. Supported feature development by refining existing algorithms and evaluating prototypes.
                        </p>
                    </div>
                    
                    <div class="experience-item">
                        <div class="experience-date">Apr 2024 - Dec 2024</div>
                        <h3 class="experience-title">Contract AI Writing Evaluator</h3>
                        <div class="experience-company">Outlier</div>
                        <p class="experience-description">
                            Evaluated and refined training data for LLMs including Google Gemini, by analyzing 2,000+ AI-generated outputs across domains such as Google Flights, Hotels, and YouTube. Applied Reinforcement Learning from Human Feedback (RLHF) to optimize AI accuracy, ensuring ethical and factual responses.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section" id="projects-section">
            <div class="about-container">
                <div class="about-header sticky-header">
                    <h1 class="about-title interactive-text">PROJECTS</h1>
                    <p class="about-subtitle">Creative Works</p>
                </div>
                
                <div class="project-cards">
                    <div class="project-card interactive-element">
                        <h3 class="project-title">Stock Price Prediction Model</h3>
                        <div class="project-tech">Python, Ridge Regression, CNN, SVR</div>
                        <p class="project-description">
                            Engineered a stock price forecasting model that achieved an R² score of 0.984, leveraging Ridge Regression, CNN, and SVR to enhance predictive accuracy. Designed data preprocessing techniques and integrated visualization tools.
                        </p>
                        <div class="project-metric">
                            <div class="metric-label">Accuracy</div>
                            <div class="metric-bar">
                                <div class="metric-fill" style="width: 98.4%"></div>
                            </div>
                            <div class="metric-value">98.4%</div>
                        </div>
                        <a href="projects\ML4641\index.html" target="_blank" class="project-button" data-cursor="hover">View Project</a>
                    </div>
                    
                    <div class="project-card interactive-element">
                        <h3 class="project-title">NLP Headline Classification Model</h3>
                        <div class="project-tech">PyTorch, NLTK, Pandas</div>
                        <p class="project-description">
                            Built an NLP classifier that distinguishes satirical from real news headlines using a Neural Bag of Words model. Implemented custom PyTorch datasets, token embeddings, and achieved 86%+ F1 score by capturing distinctive linguistic patterns in satirical writing.                        </p>
                        <div class="project-metric">
                            <div class="metric-label">F1 Score</div>
                            <div class="metric-bar">
                                <div class="metric-fill" style="width: 86.5%"></div>
                            </div>
                            <div class="metric-value">86.5%</div>
                        </div>
                        <a class="project-button" data-cursor="hover">N/A</a>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section" id="contact-section">
            <div class="about-container">
                <div class="about-header sticky-header">
                    <h1 class="about-title interactive-text">CONTACT</h1>
                    <p class="about-subtitle">Get in Touch</p>
                </div>
                
                <div class="contact-content">
                    <p class="about-text">
                        Interested in collaborating on AI projects or need a skilled developer for your team? Feel free to reach out through any of the channels below.
                    </p>
                    
                    <div class="contact-cards">
                        <div class="contact-card interactive-element">
                            <div class="contact-icon">
                                <i class="fas fa-envelope"></i>
                            </div>
                            <div class="contact-label">Email</div>
                            <div class="contact-value">mta&#110;g2&#48;21&#64;&#103;m&#97;i&#108;&#46;&#99;om</div>
                        </div>
                        
                        <div class="contact-card interactive-element">
                            <div class="contact-icon">
                                <i class="fas fa-phone"></i>
                            </div>
                            <div class="contact-label">Phone</div>
                            <div class="contact-value">+1 404-834-0526</div>
                        </div>
                        
                        <div class="contact-card interactive-element">
                            <div class="contact-icon">
                                <i class="fab fa-linkedin"></i>
                            </div>
                            <div class="contact-label">LinkedIn</div>
                            <div class="contact-value">mtang2021</div>
                        </div>
                        
                        <div class="contact-card interactive-element">
                            <div class="contact-icon">
                                <i class="fas fa-map-marker-alt"></i>
                            </div>
                            <div class="contact-label">Location</div>
                            <div class="contact-value">Morrow, Georgia</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Show intro sequence
            const introSequence = document.getElementById('intro-sequence');
            const introLogo = document.getElementById('intro-logo');
            
            // Play intro animation
            setTimeout(() => {
                introLogo.classList.add('visible');
            }, 500);
            
            setTimeout(() => {
                introLogo.classList.remove('visible');
                introSequence.style.opacity = '0';
                setTimeout(() => {
                    introSequence.style.display = 'none';
                    initializeApp();
                }, 1000);
            }, 3000);
        });
        
        function initializeApp() {
            // Initialize terminal interface
            const terminal = document.getElementById('terminal-interface');
            terminal.style.opacity = '1';
            
            // Setup physics-based cursor
            setupCursor();
            
            // Generate particle field
            generateParticleField();
            
            // Initialize terminal functionality
            initializeTerminal();
            
            // Setup interactive text
            setupInteractiveText();
            
            // Setup navigation
            setupNavigation();
            
            // Generate living data visualization
            generateSkillsVisualization();
            
            // Make project cards and contact cards interactive
            setupInteractiveElements();
        }
        
        // Physics-based cursor with trails
        function setupCursor() {
            // Skip cursor setup on touch-only devices
            if (window.matchMedia('(hover: none)').matches) {
                return;
            }
            
            // Check if we should use simplified cursor based on device performance
            const useSimplifiedCursor = !hasGoodPerformance();
            
            const cursorContainer = document.getElementById('cursor-container');
            const cursorMain = document.querySelector('.cursor-main');
            const cursorAura = document.querySelector('.cursor-aura');
            const terminalInterface = document.getElementById('terminal-interface');
            
            // Flag to track if we're hovering over the terminal
            let isOverTerminal = false;
            
            // Disable cursor effects over terminal for better performance
            terminalInterface.addEventListener('mouseenter', () => {
                isOverTerminal = true;
                cursorMain.style.opacity = useSimplifiedCursor ? '0' : '0.5';
                cursorAura.style.opacity = '0';
            });
            
            terminalInterface.addEventListener('mouseleave', () => {
                isOverTerminal = false;
                cursorMain.style.opacity = '1';
                cursorAura.style.opacity = '1';
            });
            
            // Trail properties - REDUCED number of trails for better performance
            const maxTrails = useSimplifiedCursor ? 5 : 10; // Reduced from 20
            const trails = [];
            
            // Create cursor trails
            for (let i = 0; i < maxTrails; i++) {
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.opacity = '0';
                cursorContainer.appendChild(trail);
                trails.push({
                    element: trail,
                    x: 0,
                    y: 0,
                    delay: i * (100 / maxTrails),
                    size: Math.max(2, 6 - (i * 0.25))
                });
            }
            
            // Track cursor position
            let mouseX = 0, mouseY = 0;
            let cursorX = 0, cursorY = 0;
            let isMoving = false;
            let moveTimeout;
            
            // Cache interactive elements and throttle mousemove
            let lastMouseMoveTime = 0;
            const mouseMoveThreshold = 16; // ~60fps
            
            // Pre-compute interactive elements and store them
            const interactiveSelectors = '.interactive-text, .nav-node, .particle';
            let cachedInteractiveElements = [];
            
            // Update cached elements periodically instead of on every mouse move
            function updateCachedElements() {
                cachedInteractiveElements = Array.from(document.querySelectorAll(interactiveSelectors));
                setTimeout(updateCachedElements, 2000); // Update every 2 seconds
            }
            updateCachedElements();
            
            document.addEventListener('mousemove', (e) => {
                // Throttle the mousemove event
                const now = performance.now();
                if (now - lastMouseMoveTime < mouseMoveThreshold) return;
                lastMouseMoveTime = now;
                
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                // Update cursor scale based on movement speed (simplified calculation)
                const speed = Math.abs(e.movementX) + Math.abs(e.movementY);
                const scale = 1 + Math.min(speed / 30, 0.3);
                cursorMain.style.transform = `translate(-50%, -50%) scale(${scale})`;
                
                // Check if cursor is over interactive elements - SIMPLIFIED
                const element = document.elementFromPoint(e.clientX, e.clientY);
                const isInteractive = element && (
                    element.closest('[data-cursor="hover"]') || 
                    element.tagName === 'A' || 
                    element.tagName === 'BUTTON'
                );
                
                if (isInteractive) {
                    cursorMain.style.borderColor = 'var(--highlight)';
                    cursorMain.style.transform = `translate(-50%, -50%) scale(1.5)`;
                } else {
                    cursorMain.style.borderColor = 'var(--text-color)';
                }
                
                // Skip physics calculations in simplified mode or when over terminal
                if (!useSimplifiedCursor) {
                    // Use cached elements instead of querying DOM on every move
                    cachedInteractiveElements.forEach(el => {
                        const rect = el.getBoundingClientRect();
                        
                        // Quick distance check first before more expensive calculations
                        const quickDistX = Math.abs(mouseX - (rect.left + rect.width/2));
                        const quickDistY = Math.abs(mouseY - (rect.top + rect.height/2));
                        
                        // Skip detailed calculation if we're clearly too far away
                        if (quickDistX > 120 || quickDistY > 120) return;
                        
                        const elCenterX = rect.left + rect.width / 2;
                        const elCenterY = rect.top + rect.height / 2;
                        
                        // Simplified distance calculation
                        const dx = mouseX - elCenterX;
                        const dy = mouseY - elCenterY;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Apply physics effects based on distance
                        if (distance < 100) {
                            // Reduced force for better performance
                            const force = Math.min(1 - distance / 100, 0.2);
                            const angle = Math.atan2(dy, dx);
                            const moveX = Math.cos(angle) * force * 3;
                            const moveY = Math.sin(angle) * force * 3;
                            
                            // Apply transformation
                            if (el.classList.contains('interactive-text')) {
                                el.style.transform = `translate(${moveX}px, ${moveY}px)`;
                            } else if (el.classList.contains('particle')) {
                                el.style.transform = `translate(${moveX}px, ${moveY}px)`;
                                el.style.backgroundColor = 'var(--highlight)';
                            } else {
                                el.style.transform = `translate(${moveX}px, ${moveY}px)`;
                            }
                        } else {
                            // Reset when cursor is far away
                            if (!el.classList.contains('char-wrapper')) {
                                el.style.transform = '';
                            }
                            if (el.classList.contains('particle')) {
                                el.style.backgroundColor = 'var(--highlight-dim)';
                            }
                        }
                    });
                }
            });
            
            // Animation loop for cursor and trails
            function animateCursor() {
                // Skip animation when over terminal for better performance
                // Smoothly move cursor to mouse position (easing effect)
                cursorX += (mouseX - cursorX) * 0.2;
                cursorY += (mouseY - cursorY) * 0.2;
                
                // Update main cursor position
                cursorMain.style.left = `${Math.round(cursorX)}px`;
                cursorMain.style.top = `${Math.round(cursorY)}px`;
                
                // Update cursor aura
                cursorAura.style.left = `${Math.round(cursorX)}px`;
                cursorAura.style.top = `${Math.round(cursorY)}px`;
                
                // Only update trails if we're in full effect mode
                if (!useSimplifiedCursor) {
                    // Update trails with staggered delay
                    trails.forEach((trail, index) => {
                        // Calculate trail position with delay
                        const easeFactor = 0.1 - index * 0.01;
                        trail.x += (mouseX - trail.x) * easeFactor;
                        trail.y += (mouseY - trail.y) * easeFactor;
                        
                        // Apply position - batch style updates for better performance
                        const pos = {
                            left: `${Math.round(trail.x)}px`,
                            top: `${Math.round(trail.y)}px`,
                            width: `${trail.size}px`,
                            height: `${trail.size}px`,
                            opacity: isOverTerminal ? '0' : '0.7'
                        };
                        
                        Object.assign(trail.element.style, pos);
                        
                        // Fade in trails gradually if not over terminal
                        if (!isOverTerminal && parseFloat(trail.element.style.opacity || 0) < 0.7) {
                            trail.element.style.opacity = Math.min(parseFloat(trail.element.style.opacity || 0) + 0.05, 0.7 - (index * 0.03));
                        }
                    });
                }
                
                requestAnimationFrame(animateCursor);
            }
            
            // Start animation loop
            animateCursor();
        }

        function hasGoodPerformance() {
            // Check if the user has specified a preference for reduced motion
            if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                return false;
            }
            
            // Check if the device has hardware acceleration
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            const hasHardwareAcceleration = !!gl;
            
            // No WebGL support means we should definitely use low-performance mode
            if (!hasHardwareAcceleration) {
                return false;
            }
            
            // Check CPU cores as a proxy for performance
            const cpuCores = navigator.hardwareConcurrency || 2;
            
            // Check device memory if available (Chrome only)
            const deviceMemory = navigator.deviceMemory || 4;
            
            // Perform a simple FPS test
            let lastTime = performance.now();
            let frames = 0;
            let testDone = false;
            let fps = 60; // Default assumption
            
            function frame() {
                frames++;
                const now = performance.now();
                const elapsedMs = now - lastTime;
                
                if (elapsedMs >= 500) { // Test for half a second
                    fps = (frames / elapsedMs) * 1000;
                    testDone = true;
                } else if (!testDone) {
                    requestAnimationFrame(frame);
                }
            }
            
            // Start the frame test
            requestAnimationFrame(frame);
            
            // Mobile devices often have less RAM but better GPUs
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Consider device performance good if it meets any of these criteria
            const hasGoodCPU = cpuCores >= 4;
            const hasGoodMemory = deviceMemory >= 4;
            const hasGoodFPS = fps > 40;
            
            if (isMobile) {
                // More lenient for mobile devices with hardware acceleration
                return hasHardwareAcceleration && (hasGoodCPU || hasGoodFPS);
            } else {
                // Stricter for desktops
                return hasHardwareAcceleration && hasGoodCPU && (hasGoodMemory || hasGoodFPS);
            }
        }
        
        // Generate particle field
        function generateParticleField() {
            const particleField = document.getElementById('particle-field');
            
            // OPTIMIZATION: Reduce particle count based on performance
            const useSimpleParticles = !hasGoodPerformance();
            const particleCount = useSimpleParticles ? 
                Math.min(window.innerWidth / 20, 50) : // Reduced for low-performance devices
                Math.min(window.innerWidth / 10, 120);  // Reduced from 150
            
            // Clear existing particles if any
            particleField.innerHTML = '';
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                // Position randomly
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                if (!useSimpleParticles) {
                    // Animate particle with random duration
                    const duration = 20 + Math.random() * 20;
                    particle.style.animation = `float ${duration}s infinite ease-in-out`;
                }
                
                particleField.appendChild(particle);
            }
            
            // OPTIMIZATION: Throttle scroll event
            let lastScrollTime = 0;
            const scrollThreshold = 50; // ms
            
            window.addEventListener('scroll', () => {
                const now = performance.now();
                if (now - lastScrollTime < scrollThreshold) return;
                lastScrollTime = now;
                
                const scrollY = window.scrollY;
                
                // OPTIMIZATION: Use requestAnimationFrame to handle scroll updates
                requestAnimationFrame(() => {
                    const particles = document.querySelectorAll('.particle');
                    
                    particles.forEach((particle, index) => {
                        // Create parallax effect with different speeds
                        // OPTIMIZATION: Only update every nth particle based on index for better performance
                        if (index % 3 === 0 || !useSimpleParticles) {
                            const speed = 0.05 + (index % 5) * 0.01;
                            particle.style.transform = `translateY(${scrollY * speed}px)`;
                        }
                    });
                });
            });
        }
        
        // Initialize terminal functionality
        function initializeTerminal() {
            const terminalContent = document.getElementById('terminal-content');
            const terminalInput = document.getElementById('terminal-input');
            const terminalClose = document.getElementById('terminal-close');
            const terminalMinimize = document.getElementById('terminal-minimize');
            const terminalMaximize = document.getElementById('terminal-maximize');
            
            // Terminal state
            let isMinimized = false;
            const terminalInterface = document.getElementById('terminal-interface');
            
            // Check for low performance device
            const isLowPerformance = !hasGoodPerformance();
            
            // Terminal boot sequence content - REDUCED for low performance devices
            const bootSequence = isLowPerformance ? 
            [
                { type: 'command', text: 'echo "Welcome to Michael Tang\'s Digital Ecosystem"' },
                { type: 'output', text: 'Welcome to Michael Tang\'s Digital Ecosystem' },
                { type: 'command', text: 'cat commands.txt' },
                { type: 'output', text: 'Commands: view about | view experience | view projects | view contact | clear | help' }
            ] : 
            [
                { type: 'command', text: 'echo "Welcome to Michael Tang\'s Digital Ecosystem"' },
                { type: 'output', text: 'Welcome to Michael Tang\'s Digital Ecosystem' },
                { type: 'command', text: 'whoami' },
                { type: 'output', text: 'Michael Tang - AI and Software Engineer specializing in machine learning, NLP, and financial data analysis.' },
                { type: 'command', text: 'cat navigation.txt' },
                { type: 'output', text: `Navigation Commands:` },
                { type: 'output', text: `• view about - Display information about me` },
                { type: 'output', text: `• view experience - Show professional background` },
                { type: 'output', text: `• view projects - Browse portfolio projects` },
                { type: 'output', text: `• view contact - Get contact information` },
                { type: 'output', text: `• clear - Clear the terminal` },
                { type: 'output', text: `• help - Display more command info` }
            ];
            
            // Text anim - OPTIMIZED
            function typeText(element, text, speed = 4) {
                // For low performance devices, just set the text and resolve immediately
                if (isLowPerformance) {
                    element.textContent = text;
                    return Promise.resolve();
                }
                
                return new Promise(resolve => {
                    let i = 0;
                    element.textContent = '';
                    
                    // Use a more efficient approach with batch processing
                    const chunkSize = 5; // Process characters in chunks for better performance
                    
                    function typeNextChunk() {
                        if (i < text.length) {
                            const endIndex = Math.min(i + chunkSize, text.length);
                            const chunk = text.substring(i, endIndex);
                            element.textContent += chunk;
                            i = endIndex;
                            
                            // Use requestAnimationFrame instead of setTimeout for better performance
                            // But still add a small delay to create a typing effect
                            setTimeout(() => requestAnimationFrame(typeNextChunk), speed * chunkSize);
                        } else {
                            resolve();
                        }
                    }
                    
                    requestAnimationFrame(typeNextChunk);
                });
            }

            // Function to add a line to terminal with typing animation - OPTIMIZED
            async function addTypedLine(content, isCommand = true, typingSpeed = 4) {
                const line = document.createElement('div');
                line.className = 'terminal-line';
                
                // Reduce DOM operations by setting up the entire line structure before adding to DOM
                if (isCommand) {
                    line.innerHTML = `<span class="terminal-prompt">$ </span><span class="terminal-command"></span>`;
                    const command = line.querySelector('.terminal-command');
                    
                    // Append to DOM first (better performance than multiple inserts)
                    terminalContent.insertBefore(line, terminalContent.lastElementChild);
                    
                    // Type the command character by character
                    await typeText(command, content, typingSpeed);
                } else {
                    // Simplified approach for low-performance devices
                    if (isLowPerformance) {
                        line.textContent = content;
                        terminalContent.insertBefore(line, terminalContent.lastElementChild);
                    } else {
                        terminalContent.insertBefore(line, terminalContent.lastElementChild);
                        await typeText(line, content, typingSpeed);
                    }
                }
                
                // Use requestAnimationFrame for adding the visible class
                requestAnimationFrame(() => {
                    line.classList.add('visible');
                    
                    // Scroll to bottom with a smooth effect only on high-performance devices
                    terminalContent.scrollTo({
                        top: terminalContent.scrollHeight,
                        behavior: isLowPerformance ? 'auto' : 'smooth'
                    });
                });
                
                return line;
            }

            // Start the boot sequence - OPTIMIZED
            async function startBootSequence() {
                // Faster typing for both types on low performance devices
                const commandSpeed = isLowPerformance ? 30 : 15; 
                const outputSpeed = isLowPerformance ? 10 : 5;
                
                // Shorter pauses for low performance devices
                const commandPause = isLowPerformance ? 50 : 200;
                const outputPause = isLowPerformance ? 100 : 400;
                
                // Process boot sequence with optimized promises
                for (const item of bootSequence) {
                    if (item.type === 'command') {
                        await addTypedLine(item.text, true, commandSpeed);
                        // Shorter pause on low performance devices
                        await new Promise(resolve => setTimeout(resolve, commandPause));
                    } else {
                        await addTypedLine(item.text, false, outputSpeed);
                        await new Promise(resolve => setTimeout(resolve, outputPause));
                    }
                }
                
                // Focus input after boot sequence completes
                terminalInput.focus();
            }

            // Add a new line to terminal - OPTIMIZED
            function addTerminalLine(text, isCommand = true, delay = 0) {
                const line = document.createElement('div');
                line.className = 'terminal-line';
                
                if (isCommand) {
                    line.innerHTML = `<span class="terminal-prompt">$</span> <span class="terminal-command">${text}</span>`;
                } else {
                    line.textContent = text;
                }
                
                terminalContent.insertBefore(line, terminalContent.lastElementChild);
                
                // Animate line appearance - use requestAnimationFrame for better performance
                if (delay > 0) {
                    setTimeout(() => {
                        requestAnimationFrame(() => {
                            line.classList.add('visible');
                        });
                    }, delay);
                } else {
                    requestAnimationFrame(() => {
                        line.classList.add('visible');
                    });
                }
                
                // Optimize scrolling
                if (isLowPerformance) {
                    terminalContent.scrollTop = terminalContent.scrollHeight;
                } else {
                    terminalContent.scrollTo({
                        top: terminalContent.scrollHeight,
                        behavior: 'smooth'
                    });
                }
                
                return line;
            }
            
            // Function to minimize terminal - EXTRACTED for reuse
            function minimizeTerminal() {
                terminalInterface.style.transform = 'translate(-50%, 46vh) scale(1)';
                terminalInterface.style.opacity = '0.4';
                isMinimized = true;
            }
            
            // Terminal commands
            const commands = {
                'help': () => {
                    addTerminalLine('Available commands:', false);
                    addTerminalLine('• clear - Clear the terminal', false);
                    addTerminalLine('• exit - Minimize the terminal', false);
                    addTerminalLine('• help - Display this help message', false);
                    addTerminalLine('• view [section] - View a section (about, experience, projects, contact)', false);
                },
                'clear': () => {
                    // Remove all lines except the input line - OPTIMIZED
                    const parent = terminalContent;
                    while (parent.firstChild) {
                        if (parent.firstChild.classList && parent.firstChild.classList.contains('terminal-input-line')) {
                            break;
                        }
                        parent.removeChild(parent.firstChild);
                    }
                },
                'exit': () => {
                    minimizeTerminal();
                },
                'view': (section) => {
                    if (!section) {
                        addTerminalLine('Please specify a section to view: about, experience, projects, contact', false);
                        return;
                    }
                    
                    // Find the nav node for this section - OPTIMIZED
                    const navNodes = document.querySelectorAll('.nav-node');
                    let targetNode = null;
                    
                    // Optimize the section search
                    const normalizedSection = section.toLowerCase();
                    if (normalizedSection === 'about' || normalizedSection === 'experience' || 
                        normalizedSection === 'projects' || normalizedSection === 'project' ||
                        normalizedSection === 'contact' || normalizedSection === 'contacts') {
                        
                        // Map variant names to canonical section names
                        const sectionMap = {
                            'project': 'projects',
                            'projects': 'projects',
                            'contact': 'contact',
                            'contacts': 'contact',
                            'about': 'about',
                            'experience': 'experience'
                        };
                        
                        const canonicalSection = sectionMap[normalizedSection];
                        
                        // Find matching node in a single pass
                        for (let i = 0; i < navNodes.length; i++) {
                            if (navNodes[i].dataset.section === canonicalSection) {
                                targetNode = navNodes[i];
                                break;
                            }
                        }
                    }
                    
                    if (targetNode) {
                        addTerminalLine(`Navigating to ${section} section...`, false);
                        
                        // Click the node after a slight delay to allow terminal to update
                        setTimeout(() => {
                            targetNode.click();
                            // Minimize terminal after navigation
                            setTimeout(minimizeTerminal, isLowPerformance ? 500 : 1000);
                        }, 100);
                    } else {
                        addTerminalLine(`Section "${section}" not found. Available sections: about, experience, projects, contact`, false);
                    }
                }
            };
            
            // Process terminal input
            terminalInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const input = terminalInput.value.trim();
                    terminalInput.value = '';
                    
                    if (input) {
                        // Add command to terminal
                        addTerminalLine(input, true);
                        
                        // Process command
                        const args = input.split(' ');
                        const command = args[0].toLowerCase();
                        const commandArgs = args.slice(1);
                        
                        if (commands[command]) {
                            commands[command](...commandArgs);
                        } else {
                            addTerminalLine(`Command not found: ${command}. Type 'help' for available commands.`, false);
                        }
                    }
                }
            });
            
            // Terminal controls
            terminalClose.addEventListener('click', () => {
                terminalInterface.style.opacity = '0';
                setTimeout(() => {
                    terminalInterface.style.display = 'none';
                    // Activate the constellation system when terminal is closed
                    activateConstellationSystem();
                }, 700);
            });

            terminalMinimize.addEventListener('click', () => {
                terminalInterface.style.transform = 'translate(-50%, 46vh) scale(1)';
                terminalInterface.style.opacity = '0.4';
                isMinimized = true;
                activateConstellationSystem();
            });

            terminalMaximize.addEventListener('click', () => {
                terminalInterface.style.transform = 'translate(-50%, -50%) scale(1)';
                terminalInterface.style.opacity = '1';
                isMinimized = false;
                deactivateConstellationSystem()
                
                // Focus input
                setTimeout(() => {
                    terminalInput.focus();
                }, 700);
            })
            
            // Start boot sequence after short delay
            setTimeout(() => {
                startBootSequence();
            }, 500);
        }
        
        // Setup interactive text
        function setupInteractiveText() {
            const interactiveTextElements = document.querySelectorAll('.interactive-text');
            
            interactiveTextElements.forEach(element => {
                const text = element.textContent;
                element.textContent = '';
                
                // Create dynamic shape for this text element
                const dynamicShape = document.createElement('div');
                dynamicShape.className = 'dynamic-shape';
                element.appendChild(dynamicShape);
                
                // Split text into characters
                for (let i = 0; i < text.length; i++) {
                    const charWrapper = document.createElement('span');
                    charWrapper.className = 'char-wrapper';
                    charWrapper.textContent = text[i];
                    
                    // Set initial random position
                    charWrapper.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                    charWrapper.style.opacity = '0';
                    
                    element.appendChild(charWrapper);
                    
                    // Animate character into position
                    setTimeout(() => {
                        charWrapper.style.transform = 'translate(0, 0)';
                        charWrapper.style.opacity = '1';
                    }, 500 + i * 10);
                }
                
                // Track mouse position for this text element
                element.addEventListener('mousemove', (e) => {
                    const rect = element.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Position the dynamic shape
                    dynamicShape.style.left = x + 'px';
                    dynamicShape.style.top = y + 'px';
                    dynamicShape.style.opacity = '1';
                    
                    // Affect characters based on proximity
                    const charWrappers = element.querySelectorAll('.char-wrapper');
                    charWrappers.forEach((charWrapper, index) => {
                        const charRect = charWrapper.getBoundingClientRect();
                        const charX = charRect.left + charRect.width / 2 - rect.left;
                        const charY = charRect.top + charRect.height / 2 - rect.top;
                        
                        // Calculate distance
                        const dx = x - charX;
                        const dy = y - charY;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Apply effects based on distance
                        if (distance < 50) {
                            // Repulsion effect
                            const force = (1 - distance / 50) * 10;
                            const angle = Math.atan2(dy, dx);
                            const moveX = -Math.cos(angle) * force;
                            const moveY = -Math.sin(angle) * force;
                            
                            charWrapper.style.transform = `translate(${moveX}px, ${moveY}px)`;
                            charWrapper.style.color = 'var(--highlight)';
                            charWrapper.style.textShadow = 'var(--glow)';
                        } else {
                            // Reset
                            charWrapper.style.transform = 'translate(0, 0)';
                            charWrapper.style.color = '';
                            charWrapper.style.textShadow = '';
                        }
                    });
                });
                
                // Reset on mouse leave
                element.addEventListener('mouseleave', () => {
                    dynamicShape.style.opacity = '0';
                    
                    const charWrappers = element.querySelectorAll('.char-wrapper');
                    charWrappers.forEach(charWrapper => {
                        charWrapper.style.transform = 'translate(0, 0)';
                        charWrapper.style.color = '';
                        charWrapper.style.textShadow = '';
                    });
                });
            });
        }
        
        // Setup navigation
        function setupNavigation() {
            const navNodes = document.querySelectorAll('.nav-node');
            const sections = document.querySelectorAll('.section');
            
            navNodes.forEach(node => {
                node.addEventListener('click', () => {
                    // Update active state
                    navNodes.forEach(n => n.classList.remove('active'));
                    deactivateConstellationSystem()
                    node.classList.add('active');
                    
                    const sectionId = node.dataset.section;
                    
                    // Intro is special case
                    if (sectionId === 'intro') {
                        sections.forEach(section => {
                            section.classList.remove('active');
                        });
                        
                        // Show terminal
                        const terminal = document.getElementById('terminal-interface');
                        terminal.style.display = 'block';
                        terminal.style.opacity = '1';
                        terminal.style.transform = 'translate(-50%, -50%) scale(1)';
                        return;
                    }
                    
                    // Hide terminal if visible
                    const terminal = document.getElementById('terminal-interface');
                    terminal.style.opacity = '0.4';
                    terminal.style.transform = 'translate(-50%, 40vh) scale(0.2)';
                    
                    // Show selected section
                    sections.forEach(section => {
                        if (section.id === `${sectionId}-section`) {
                            section.classList.add('active');
                            
                            // Animate experience items if showing experience section
                            if (sectionId === 'experience') {
                                const experienceItems = section.querySelectorAll('.experience-item');
                                experienceItems.forEach((item, index) => {
                                    setTimeout(() => {
                                        item.classList.add('visible');
                                    }, 300 + index * 200);
                                });
                            }
                        } else {
                            section.classList.remove('active');
                        }
                    });
                });
            });
        }
        
        function generateSkillsVisualization() {
            const container = document.getElementById('skills-visualization');
            if (!container) return;
            
            // Skills data with ratings
            const skills = [
                { name: 'Python', value: 85 },
                { name: 'NLP', value: 78 },
                { name: 'Machine Learning', value: 85 },
                { name: 'LLM Fine-tuning', value: 94 },
                { name: 'Data Analysis', value: 92 },
                { name: 'RLHF', value: 94 }
            ];
            
            // Clear container if needed
            container.innerHTML = '';
            
            // Use lightweight visualization for low-performance devices
            const useSimpleViz = !hasGoodPerformance();
            
            // Function to calculate responsive sizing
            function getResponsiveRadius(skillValue) {
                const isMobile = window.innerWidth <= 768;
                const isSmallMobile = window.innerWidth <= 480;
                const containerWidth = container.offsetWidth;
                const padding = isSmallMobile ? 80 : (isMobile ? 100 : 130);
                
                return (skillValue / 100) * (containerWidth / 2 - padding);
            }
            
            // Function to adjust font size based on screen width
            function getResponsiveFontSize() {
                if (window.innerWidth <= 480) return '12px';
                if (window.innerWidth <= 768) return '14px';
                return '16px';
            }
            
            // Function to create/update visualization
            function createVisualization() {
                // Clear previous content
                container.innerHTML = '';
                
                // Generate data points
                skills.forEach((skill, index) => {
                    const angle = (index / skills.length) * Math.PI * 2;
                    const radius = getResponsiveRadius(skill.value);
                    
                    // Calculate position
                    const x = container.offsetWidth / 2 + Math.cos(angle) * radius;
                    const y = container.offsetHeight / 2 + Math.sin(angle) * radius;
                    
                    // Create data point
                    const dataPoint = document.createElement('div');
                    dataPoint.className = 'data-point';
                    dataPoint.setAttribute('data-skill', skill.name);
                    dataPoint.style.left = `${x}px`;
                    dataPoint.style.top = `${y}px`;
                    
                    // Add tooltip functionality with less DOM manipulation
                    if (!useSimpleViz) {
                        dataPoint.addEventListener('mouseenter', () => {
                            const tooltip = document.createElement('div');
                            tooltip.className = 'tooltip';
                            tooltip.textContent = `${skill.name}: ${skill.value}%`;
                            tooltip.style.position = 'absolute';
                            tooltip.style.left = `${x}px`;
                            tooltip.style.top = `${y - 20}px`;
                            tooltip.style.backgroundColor = 'var(--highlight)';
                            tooltip.style.color = 'var(--bg-color)';
                            tooltip.style.padding = '5px';
                            tooltip.style.borderRadius = '3px';
                            tooltip.style.fontSize = '12px';
                            tooltip.style.pointerEvents = 'none';
                            tooltip.style.zIndex = '1000';
                            container.appendChild(tooltip);
                            
                            dataPoint.addEventListener('mouseleave', () => {
                                tooltip.remove();
                            });
                        });
                    }
                    
                    // Connect to center with line
                    const line = document.createElement('div');
                    line.className = 'data-line';
                    line.style.left = `${container.offsetWidth / 2}px`;
                    line.style.top = `${container.offsetHeight / 2}px`;
                    line.style.width = `${radius}px`;
                    line.style.transform = `rotate(${angle}rad)`;
                    
                    container.appendChild(line);
                    container.appendChild(dataPoint);
                    
                    // Add label
                    const label = document.createElement('div');
                    label.className = 'data-label';
                    label.textContent = skill.name;
                    label.style.position = 'absolute';
                    label.style.left = `${x}px`;
                    label.style.top = `${y}px`;
                    label.style.transform = 'translate(-50%, 50%)';
                    label.style.fontSize = getResponsiveFontSize();
                    label.style.color = 'var(--highlight)';
                    
                    container.appendChild(label);
                });
            }
            
            // Create initial visualization
            createVisualization();
            
            // Add resize handler with debounce
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function() {
                    createVisualization();
                }, 250);
            });
            
            // Only animate for high-performance devices
            if (!useSimpleViz) {
                let lastAnimationTime = 0;
                const animationThreshold = 100; // ms between animations
                
                function animateSkills(timestamp) {
                    if (timestamp - lastAnimationTime >= animationThreshold) {
                        lastAnimationTime = timestamp;
                        
                        const dataPoints = container.querySelectorAll('.data-point');
                        const lines = container.querySelectorAll('.data-line');
                        
                        dataPoints.forEach((point, index) => {
                            // Get current position
                            const skill = skills[index];
                            const angle = (index / skills.length) * Math.PI * 2;
                            
                            // OPTIMIZATION: Reduced oscillation amount
                            const oscillation = Math.sin(Date.now() / 1000 + index) * 2; 
                            const radius = getResponsiveRadius(skill.value + oscillation);
                            
                            // Update position
                            const x = container.offsetWidth / 2 + Math.cos(angle) * radius;
                            const y = container.offsetHeight / 2 + Math.sin(angle) * radius;
                            
                            point.style.left = `${x}px`;
                            point.style.top = `${y}px`;
                            
                            // Update line
                            lines[index].style.width = `${radius}px`;
                        });
                    }
                    
                    requestAnimationFrame(animateSkills);
                }
                
                requestAnimationFrame(animateSkills);
            }
        }

        // Make project cards and contact cards interactive
        function setupInteractiveElements() {
            // Make project and contact cards interactive
            const interactiveElements = document.querySelectorAll('.interactive-element');
            
            interactiveElements.forEach(element => {
                element.addEventListener('mouseenter', () => {
                    element.style.transform = 'translateY(-5px)';
                    element.style.boxShadow = 'var(--glow)';
                });
                
                element.addEventListener('mouseleave', () => {
                    element.style.transform = '';
                    element.style.boxShadow = '';
                });
                
                // Make the element physically responsive to cursor
                element.setAttribute('data-cursor', 'hover');
            });
            
            const metricFills = document.querySelectorAll('.metric-fill');
            
            // Only animate for high-performance devices
            if (hasGoodPerformance()) {
                metricFills.forEach(fill => {
                    // Initial width from style
                    const baseWidth = parseFloat(fill.style.width || '0');
                    
                    // Use requestAnimationFrame instead of setInterval
                    let lastPulseTime = 0;
                    const pulseInterval = 1000; // ms
                    
                    function pulseFill(timestamp) {
                        if (timestamp - lastPulseTime >= pulseInterval) {
                            lastPulseTime = timestamp;
                            
                            // Add small random variation
                            const variation = Math.random() * 1.2 - 0.6; // Reduced range
                            const newWidth = Math.max(0, Math.min(100, baseWidth + variation));
                            fill.style.width = `${newWidth}%`;
                        }
                        
                        requestAnimationFrame(pulseFill);
                    }
                    
                    requestAnimationFrame(pulseFill);
                });
            }
        }

        // Interactive Constellation System
        function setupConstellationSystem() {
            const constellationSystem = document.getElementById('constellation-system');
            const canvas = document.getElementById('constellation-canvas');
            const ctx = canvas.getContext('2d');
            const restoreButton = document.getElementById('restore-terminal');
            
            // Set canvas to full viewport size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            // Track if system is active
            let isActive = false;
            
            // Resize on window resize
            window.addEventListener('resize', () => {
                if (isActive) {
                    resizeCanvas();
                    drawConstellations();
                }
            });
            
            // Create constellation stars
            const stars = [];
            const constellations = [];
            
            // Star class for constellation points
            class Star {
                constructor(x, y, size, brightness) {
                    this.x = x;
                    this.y = y;
                    this.originalX = x;
                    this.originalY = y;
                    this.size = size || 2 + Math.random() * 4;
                    this.brightness = brightness || 0.5 + Math.random() * 0.5;
                    this.color = `rgba(255, 255, 255, ${this.brightness})`;
                    this.highlightColor = `rgba(${Math.floor(155 + 100 * this.brightness)}, 255, 255, ${this.brightness})`;
                    this.isHighlighted = false;
                    this.isDragging = false;
                    this.velocityX = 0;
                    this.velocityY = 0;
                    this.damping = 0.9;
                    this.connections = [];
                }
                
                draw(ctx) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.isHighlighted ? this.highlightColor : this.color;
                    
                    // Add glow effect
                    if (this.isHighlighted || this.isDragging) {
                        ctx.shadowColor = 'rgba(120, 255, 255, 0.8)';
                        ctx.shadowBlur = 15;
                    } else {
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.fill();
                    ctx.closePath();
                }
                
                update() {
                    if (!this.isDragging) {
                        // Apply velocity with damping
                        this.velocityX *= this.damping;
                        this.velocityY *= this.damping;
                        
                        this.x += this.velocityX;
                        this.y += this.velocityY;
                        
                        // Optional: Gentle pull back to original position
                        const pullStrength = 0.0002;
                        this.velocityX += (this.originalX - this.x) * pullStrength;
                        this.velocityY += (this.originalY - this.y) * pullStrength;
                    }
                }
                
                contains(px, py) {
                    const dx = this.x - px;
                    const dy = this.y - py;
                    return Math.sqrt(dx * dx + dy * dy) <= this.size + 10; // Extra 10px for easier selection
                }
            }
            
            // Constellation class to group stars
            class Constellation {
                constructor(name, connections) {
                    this.name = name;
                    this.connections = connections; // Array of [starIndex1, starIndex2]
                }
                
                draw(ctx, stars) {
                    ctx.strokeStyle = 'rgba(120, 180, 255, 0.4)';
                    ctx.lineWidth = 1;
                    
                    this.connections.forEach(connection => {
                        const star1 = stars[connection[0]];
                        const star2 = stars[connection[1]];
                        
                        ctx.beginPath();
                        ctx.moveTo(star1.x, star1.y);
                        ctx.lineTo(star2.x, star2.y);
                        
                        // Highlight line if either star is highlighted or dragging
                        if (star1.isHighlighted || star2.isHighlighted || 
                            star1.isDragging || star2.isDragging) {
                            ctx.strokeStyle = 'rgba(120, 255, 255, 0.7)';
                            ctx.lineWidth = 2;
                        } else {
                            ctx.strokeStyle = 'rgba(120, 180, 255, 0.4)';
                            ctx.lineWidth = 1;
                        }
                        
                        ctx.stroke();
                        ctx.closePath();
                    });
                    
                    // Only draw label if any star is highlighted
                    const isAnyStarHighlighted = this.connections.some(connection => 
                        stars[connection[0]].isHighlighted || stars[connection[1]].isHighlighted
                    );
                    
                    if (isAnyStarHighlighted) {
                        // Calculate center position of constellation
                        let centerX = 0, centerY = 0, starCount = 0;
                        const uniqueStars = new Set();
                        
                        this.connections.forEach(connection => {
                            if (!uniqueStars.has(connection[0])) {
                                uniqueStars.add(connection[0]);
                                centerX += stars[connection[0]].x;
                                centerY += stars[connection[0]].y;
                                starCount++;
                            }
                            if (!uniqueStars.has(connection[1])) {
                                uniqueStars.add(connection[1]);
                                centerX += stars[connection[1]].x;
                                centerY += stars[connection[1]].y;
                                starCount++;
                            }
                        });
                        
                        centerX /= starCount;
                        centerY /= starCount;
                        
                        // Draw label
                        ctx.font = '16px var(--font-mono)';
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.textAlign = 'center';
                        ctx.fillText(this.name, centerX, centerY - 30);
                    }
                }
            }
            
            // Initialize constellations
            function initConstellations() {
                // Clear existing stars and constellations
                stars.length = 0;
                constellations.length = 0;
                
                const width = canvas.width;
                const height = canvas.height;
                
                // Create Big Dipper
                const bigDipperStars = [
                    new Star(width * 0.2, height * 0.3, 3, 0.9),
                    new Star(width * 0.3, height * 0.25, 4, 0.95),
                    new Star(width * 0.35, height * 0.27, 3, 0.9),
                    new Star(width * 0.40, height * 0.31, 3.5, 0.9),
                    new Star(width * 0.41, height * 0.36, 3, 0.85),
                    new Star(width * 0.48, height * 0.34, 4, 0.95),
                    new Star(width * 0.49, height * 0.26, 3, 0.9)
                ];
                
                // Create Orion
                const orionStars = [
                    new Star(width * 0.6, height * 0.2, 4, 0.95), // 0
                    new Star(width * 0.61, height * 0.3, 4, 0.95), // 1
                    new Star(width * 0.62, height * 0.29, 3, 0.9), // 2
                    new Star(width * 0.635, height * 0.19, 3.5, 0.85), // 3
                    new Star(width * 0.635, height * 0.4, 3, 0.9), // 4
                    new Star(width * 0.65, height * 0.43, 4, 0.95), // 5
                    new Star(width * 0.68, height * 0.57, 3, 0.85), // 6
                    new Star(width * 0.65, height * 0.70, 3, 0.85), // 7
                    new Star(width * 0.75, height * 0.68, 4, 0.95), // 8
                    new Star(width * 0.70, height * 0.53, 3, 0.85), // 9
                    new Star(width * 0.69, height * 0.55, 4, 0.95), // 10
                    new Star(width * 0.715, height * 0.45, 3, 0.90), // 11
                    new Star(width * 0.69, height * 0.38, 3, 0.85), // 12
                    new Star(width * 0.80, height * 0.43, 4, 0.95), // 13 <--- bow
                    new Star(width * 0.795, height * 0.46, 3, 0.90), // 14
                    new Star(width * 0.79, height * 0.5, 3, 0.90), // 15
                    new Star(width * 0.78, height * 0.51, 3, 0.90), // 16
                    new Star(width * 0.80, height * 0.40, 3, 0.90), // 17
                    new Star(width * 0.79, height * 0.38, 3, 0.90), // 18
                ];
                
                // Create Cassiopeia
                const cassiopeiaStars = [
                    new Star(width * 0.3, height * 0.52, 3, 0.9),
                    new Star(width * 0.34, height * 0.60, 3.5, 0.95),
                    new Star(width * 0.37, height * 0.59, 4, 0.95),
                    new Star(width * 0.39, height * 0.70, 3, 0.9),
                    new Star(width * 0.44, height * 0.62, 3.5, 0.9)
                ];
                
                // Add random stars
                const randomStarCount = Math.floor(width * height / 10000);
                for (let i = 0; i < randomStarCount; i++) {
                    stars.push(new Star(
                        Math.random() * width,
                        Math.random() * height,
                        0.5 + Math.random() * 1.5,
                        0.3 + Math.random() * 0.4
                    ));
                }
                
                // Add constellation stars to the main array
                const bigDipperStartIndex = stars.length;
                stars.push(...bigDipperStars);
                
                const orionStartIndex = stars.length;
                stars.push(...orionStars);
                
                const cassiopeiaStartIndex = stars.length;
                stars.push(...cassiopeiaStars);
                
                // Define constellation connections
                constellations.push(new Constellation("Big Dipper", [
                    [bigDipperStartIndex, bigDipperStartIndex + 1],
                    [bigDipperStartIndex + 1, bigDipperStartIndex + 2],
                    [bigDipperStartIndex + 2, bigDipperStartIndex + 3],
                    [bigDipperStartIndex + 3, bigDipperStartIndex + 4],
                    [bigDipperStartIndex + 4, bigDipperStartIndex + 5],
                    [bigDipperStartIndex + 5, bigDipperStartIndex + 6],
                    [bigDipperStartIndex + 6, bigDipperStartIndex + 3]
                ]));
                
                constellations.push(new Constellation("Orion", [
                    [orionStartIndex, orionStartIndex + 1],
                    [orionStartIndex + 1, orionStartIndex + 2],
                    [orionStartIndex + 2, orionStartIndex + 3],
                    [orionStartIndex + 1, orionStartIndex + 4],
                    [orionStartIndex + 4, orionStartIndex + 5],
                    [orionStartIndex + 5, orionStartIndex + 6],
                    [orionStartIndex + 6, orionStartIndex + 7],
                    [orionStartIndex + 7, orionStartIndex + 8],
                    [orionStartIndex + 8, orionStartIndex + 9],
                    [orionStartIndex + 6, orionStartIndex + 10],
                    [orionStartIndex + 9, orionStartIndex + 10],
                    [orionStartIndex + 9, orionStartIndex + 11],
                    [orionStartIndex + 11, orionStartIndex + 12],
                    [orionStartIndex + 5, orionStartIndex + 12],
                    [orionStartIndex + 11, orionStartIndex + 13],
                    [orionStartIndex + 13, orionStartIndex + 14],
                    [orionStartIndex + 14, orionStartIndex + 15],
                    [orionStartIndex + 15, orionStartIndex + 16],
                    [orionStartIndex + 13, orionStartIndex + 17],
                    [orionStartIndex + 17, orionStartIndex + 18]
                ]));
                
                constellations.push(new Constellation("Cassiopeia", [
                    [cassiopeiaStartIndex, cassiopeiaStartIndex + 1],
                    [cassiopeiaStartIndex + 1, cassiopeiaStartIndex + 2],
                    [cassiopeiaStartIndex + 2, cassiopeiaStartIndex + 3],
                    [cassiopeiaStartIndex + 3, cassiopeiaStartIndex + 4]
                ]));
                
                // Build the connections array for each star
                stars.forEach((star, starIndex) => {
                    constellations.forEach(constellation => {
                        constellation.connections.forEach(connection => {
                            if (connection[0] === starIndex) {
                                star.connections.push(connection[1]);
                            } else if (connection[1] === starIndex) {
                                star.connections.push(connection[0]);
                            }
                        });
                    });
                });
            }
            
            // Draw all constellations
            function drawConstellations() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw stars
                stars.forEach(star => {
                    star.update();
                    star.draw(ctx);
                });
                
                // Draw constellation connections
                constellations.forEach(constellation => {
                    constellation.draw(ctx, stars);
                });
                
                // Continue animation if active
                if (isActive) {
                    requestAnimationFrame(drawConstellations);
                }
            }
            
            // Mouse interaction variables
            let isDragging = false;
            let dragTarget = null;
            let lastMouseX = 0;
            let lastMouseY = 0;
            
            // Set up mouse/touch events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            
            function handleMouseDown(e) {
                if (!isActive) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Check if we're clicking on a star
                for (let i = stars.length - 1; i >= 0; i--) {
                    if (stars[i].size > 2 && stars[i].contains(mouseX, mouseY)) {
                        isDragging = true;
                        dragTarget = stars[i];
                        dragTarget.isDragging = true;
                        lastMouseX = mouseX;
                        lastMouseY = mouseY;
                        break;
                    }
                }
            }
            
            function handleMouseMove(e) {
                if (!isActive) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Highlight stars on hover
                let hovering = false;
                stars.forEach(star => {
                    if (star.size > 2 && star.contains(mouseX, mouseY)) {
                        star.isHighlighted = true;
                        hovering = true;
                    } else if (!star.isDragging) {
                        star.isHighlighted = false;
                    }
                });
                
                // Move star if dragging
                if (isDragging && dragTarget) {
                    const dx = mouseX - lastMouseX;
                    const dy = mouseY - lastMouseY;
                    
                    dragTarget.x += dx;
                    dragTarget.y += dy;
                    
                    // Store velocity for momentum
                    dragTarget.velocityX = dx * 0.2;
                    dragTarget.velocityY = dy * 0.2;
                    
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                }
            }
            
            function handleMouseUp() {
                if (dragTarget) {
                    dragTarget.isDragging = false;
                    dragTarget = null;
                }
                isDragging = false;
            }
            
            function handleTouchStart(e) {
                e.preventDefault();
                if (!isActive) return;
                
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Check if we're touching a star
                for (let i = stars.length - 1; i >= 0; i--) {
                    if (stars[i].size > 2 && stars[i].contains(touchX, touchY)) {
                        isDragging = true;
                        dragTarget = stars[i];
                        dragTarget.isDragging = true;
                        lastMouseX = touchX;
                        lastMouseY = touchY;
                        break;
                    }
                }
            }
            
            function handleTouchMove(e) {
                e.preventDefault();
                if (!isActive || !isDragging || !dragTarget) return;
                
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                const dx = touchX - lastMouseX;
                const dy = touchY - lastMouseY;
                
                dragTarget.x += dx;
                dragTarget.y += dy;
                
                // Store velocity for momentum
                dragTarget.velocityX = dx * 0.2;
                dragTarget.velocityY = dy * 0.2;
                
                lastMouseX = touchX;
                lastMouseY = touchY;
            }
            
            function handleTouchEnd() {
                if (dragTarget) {
                    dragTarget.isDragging = false;
                    dragTarget = null;
                }
                isDragging = false;
            }
            
            // Activate/deactivate functions
            function activate() {
                isActive = true;
                constellationSystem.style.display = 'block';
                setTimeout(() => {
                    constellationSystem.style.opacity = '1';
                }, 100);
                
                resizeCanvas();
                initConstellations();
                drawConstellations();
            }
            
            function deactivate() {
                isActive = false;
                constellationSystem.style.opacity = '0';
                setTimeout(() => {
                    constellationSystem.style.display = 'none';
                }, 700);
            }
            
            // Return public methods
            return {
                activate,
                deactivate
            };
        }
        
        // Initialize the constellation system
        let constellationSystem;
        
        function activateConstellationSystem() {
            if (!constellationSystem) {
                constellationSystem = setupConstellationSystem();
            }
            constellationSystem.activate();
        }
        
        function deactivateConstellationSystem() {
            if (constellationSystem) {
                constellationSystem.deactivate();
            }
        }
    </script>
</body>
</html>
